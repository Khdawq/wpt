<!DOCTYPE html>
<meta charset="utf-8"/>
<title>Service Worker: Partitioned Service Workers</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/test-helpers.sub.js"></script>
<script src="/common/get-host-info.sub.js"></script>


<body>
  The 3p iframe's postMessage:
  <p id="3p_iframe_response">No message received</p>

<script>

promise_test(async t => {
  const script = './resources/partitioned-storage-sw.js'
  const scope = './resources/partitioned-'

  // Add service worker to this 1P context.
  const reg = await service_worker_unregister_and_register(t, script, scope);
  t.add_cleanup(() => reg.unregister());
  await wait_for_state(t, reg.installing, 'activated');

  // Now open an iframe that will wait on the SW's Promise.
  // Add a query param to make it easier to debug which request the service
  // worker is handling.
  const popup_url_wait = new URL('./resources/partitioned-waitUntilResolved.fakehtml?FromTest', self.location);

  var called_first_party_resolve = false;
  const frame_wait = with_iframe(popup_url_wait);
  // This promise chain will settle when the SW's internal promise is settled
  // (which happens when a request is made to partitioned-resolve.fakehtml).
  const frame_wait_then = frame_wait.then(() => {
    assert_equals(true, called_first_party_resolve, "Ran in correct order");
  });

  // Now create a 3p iframe that will try to resolve the SW in a 3p context.
  const third_party_origin = new URL('./resources/partitioned-service-worker-third-party-window.html', get_host_info().HTTPS_NOTSAMESITE_ORIGIN + self.location.pathname);

  // We'll wait on a postMessage from the 3p to know if it's done.
  const message_promise = new Promise(resolve => {
    self.addEventListener('message', evt => {
      resolve(evt.data);
    });
  });

  const w = window.open(third_party_origin);
  t.add_cleanup(() => w.close());

  // This promise is waiting on the 3p iframe opened within `w` to postMessage.
  // (The message is forwarded through `w` to this window). That message is only
  // sent after the 3p iframe's service worker resolves its internal promise.
  //
  // So in effect: This promise resolves once the 3p iframe's SW runs the
  // "resolve" branch of its fetch handler.
  //
  // Meaning that once this promise resolves we can safely assume that `w` did
  // its job and `frame_wait_then` will have already resolved by now if it's
  // going to. (Note: We don't want it to resolvce by this point, as that would
  // mean the test has failed.)
  await message_promise.then(data => {
    document.getElementById("3p_iframe_response").innerHTML = data;
  })

  // Now that the 3p work is done, let's resolve the SW's Promise from a 1p
  // context.
  const popup_url_resolve = new URL('./resources/partitioned-resolve.fakehtml?FromTest', self.location);
  // Set this flag so `frame_wait_then` passes.
  called_first_party_resolve = true;
  const frame_resolve = await with_iframe(popup_url_resolve);

  return frame_wait_then;

}, 'Services workers under different top-level sites are partitioned.');

</script>
</body>